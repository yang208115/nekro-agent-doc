# Async Tasks Tool

> ‚ö†Ô∏è This feature is available only in **nekro-agent v2.2.0+** or the current preview version.

## Overview

Async Tasks Tool allows plugins to execute long-running background tasks without blocking the main AI's conversation capability.

### Use Cases

- **Web App Development**: AI generates complete apps in background, frontend continues conversation
- **Video/Image Generation**: Time-consuming content generation without interrupting conversation
- **Data Processing**: Large-scale data processing runs in background
- **External API Calls**: Waiting for long-running API responses

### Key Features

- ‚úÖ **Non-blocking**: Main AI can continue conversation
- ‚úÖ **Status Tracking**: Real-time progress reporting
- ‚úÖ **Interruptible**: Support for cancelling running tasks
- ‚úÖ **Bidirectional Communication**: Tasks can notify main Agent

---

## Core API

### 1. Define Async Task

Use `mount_async_task` decorator to register async task functions:

```python
from nekro_agent.services.plugin.task import AsyncTaskHandle, TaskCtl, task
from nekro_agent.api.plugin import NekroPlugin
from typing import AsyncGenerator

plugin = NekroPlugin(
    name="My Async Plugin",
    module_name="my_async_plugin",
    description="Async task example plugin",
    version="1.0.0",
    author="Developer",
    url="https://github.com/xxx",
)

@plugin.mount_async_task("my_task")
async def my_async_task(
    handle: AsyncTaskHandle,
    prompt: str,
    task_id: str,
) -> AsyncGenerator[TaskCtl, None]:
    """Async task example"""
    # Report progress
    yield TaskCtl.report_progress("üîç Analyzing requirements...", 10)

    # Check if cancelled
    if handle.is_cancelled:
        yield TaskCtl.cancel("Task cancelled")
        return

    # Execute task steps
    yield TaskCtl.report_progress("‚öôÔ∏è Processing...", 50)

    # Task completed
    yield TaskCtl.success("Processing complete", data={"result": "success"})
```

### 2. Task Control Signals (TaskCtl)

Tasks report status via `yield TaskCtl.xxx()`:

| Method | Description | Terminal |
|--------|-------------|----------|
| `TaskCtl.report_progress(msg, percent)` | Report progress | ‚ùå |
| `TaskCtl.success(msg, data)` | Success | ‚úÖ |
| `TaskCtl.fail(msg, error)` | Failure | ‚úÖ |
| `TaskCtl.cancel(msg)` | Cancelled | ‚úÖ |

### 3. Task Handle (AsyncTaskHandle)

Task functions receive `AsyncTaskHandle` parameter:

| Method | Description |
|--------|-------------|
| `handle.wait(key, timeout)` | Wait for external signal |
| `handle.notify(key, data)` | Notify wait point to resume |
| `handle.notify_agent(message)` | Notify main Agent |
| `handle.is_cancelled` | Check if cancelled |

### 4. Global Task API (task)

Control tasks via `task` global object:

| Method | Description |
|--------|-------------|
| `await task.start(type, id, chat_key, plugin, ...)` | Start task |
| `task.is_running(type, id)` | Check if running |
| `await task.cancel(type, id)` | Cancel task |
| `await task.stop_all()` | Stop all tasks |
| `task.get_handle(type, id)` | Get task handle |

---

## Complete Example: WebApp Development Task

### Define Async Task

```python
@plugin.mount_async_task("webapp_dev")
async def webapp_development_task(
    handle: AsyncTaskHandle,
    requirement: str,
    task_id: str,
) -> AsyncGenerator[TaskCtl, None]:
    """WebApp development async task"""
    yield TaskCtl.report_progress("üöÄ Starting development...", 0)

    # Execute development
    success, result = await run_developer_loop(requirement)

    if success:
        yield TaskCtl.report_progress("üì¶ Compiling...", 70)
        yield TaskCtl.success("Deployment successful", data={"url": url})
    else:
        yield TaskCtl.fail(f"Development failed: {result}")
```

### Start Task

```python
from nekro_agent.api.schemas import AgentCtx

@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "create_webapp_task")
async def create_webapp_task(
    _ctx: AgentCtx,
    requirement: str,
) -> str:
    """Create WebApp development task"""
    task_id = generate_task_id()

    # Start async task (non-blocking)
    await task.start(
        task_type="webapp_dev",
        task_id=task_id,
        chat_key=_ctx.chat_key,
        plugin=plugin,
        requirement=requirement,
        task_id=task_id,
    )

    return f"Task started: {task_id}"
```

### Interact with Main Agent

```python
# Notify main Agent after task completion
await handle.notify_agent(
    f"‚úÖ WebApp deployed successfully!\nüîó {url}"
)

# Real-time feedback (interrupt current operation)
state_obj = runtime_state.get_state(chat_key, task_id)
if state_obj and state_obj.inject_feedback(new_requirement):
    return "‚ö° Feedback injected"
```

---

## Best Practices

### 1. Task Design

```python
# ‚úÖ Recommended: Clear task phases
yield TaskCtl.report_progress("üì• Downloading resources...", 20)
yield TaskCtl.report_progress("üîÑ Processing...", 60)
yield TaskCtl.report_progress("üíæ Saving...", 90)

# ‚ùå Not recommended: Vague progress
yield TaskCtl.report_progress("Processing...", 50)
yield TaskCtl.report_progress("Almost done...", 80)
```

### 2. Error Handling

```python
try:
    result = await external_api()
    yield TaskCtl.success("Complete", data=result)
except TimeoutError:
    yield TaskCtl.fail("API timeout")
except Exception as e:
    yield TaskCtl.fail(f"Error: {e}")
```

### 3. Resource Cleanup

```python
@plugin.on_disabled()
async def cleanup():
    count = await task.stop_all()
    if count > 0:
        logger.info(f"Stopped {count} tasks")
```

### 4. Concurrency Control

```python
MAX_CONCURRENT_TASKS = 3

@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "start_task")
async def start_task(_ctx: AgentCtx, name: str) -> str:
    active = len([t for t in task.get_running_tasks() if "my_plugin" in t])
    if active >= MAX_CONCURRENT_TASKS:
        raise ValueError(f"Max concurrent tasks reached ({MAX_CONCURRENT_TASKS})")

    await task.start("my_task", task_id, _ctx.chat_key, plugin, name)
    return f"Task started: {task_id}"
```

---

## FAQ

### Q: What's the difference between async tasks and regular sandbox methods?

| Comparison | Sandbox Method | Async Task |
|------------|----------------|------------|
| Execution | Immediate on call | Background after call |
| Block main conversation | Blocks | Non-blocking |
| Status tracking | None | Full progress |
| Long-running | Not suitable | Suitable |
| Cancellable | No | Yes |

### Q: How to make task wait for user confirmation?

```python
@plugin.mount_async_task("approval_task")
async def task_with_approval(handle: AsyncTaskHandle, prompt: str):
    yield TaskCtl.report_progress("‚è≥ Waiting for approval...", 50)

    # Wait for external notify() call
    approved = await handle.wait("approval", timeout=3600)

    if approved:
        yield TaskCtl.success("Approved")
    else:
        yield TaskCtl.fail("Approval timeout or rejected")
```

### Q: How to notify user after task completion?

```python
await handle.notify_agent(
    f"‚úÖ Task completed!\nResult: {result}"
)
```

---

## Version Info

- **Feature Version**: nekro-agent v2.2.0+
- **Document Version**: 1.0.0
- **Last Updated**: 2026-01-30
