# 非同期タスクツール

> ⚠️ この機能は **nekro-agent v2.2.0+** または現在のプレビューでのみ利用可能です。

## 概要

非同期タスクツールを使用すると、プラグインは長時間実行されるバックグラウンドタスクを実行しながら、メイン AI の会話能力をブロックしません。

### ユースケース

- **Web アプリ開発**: AI がバックグラウンドで完全なアプリを生成、フロントエンドは会話継続
- **動画/画像生成**: 時間のかかるコンテンツ生成で会話中断なし
- **データ処理**: 大規模データ処理がバックグラウンドで実行
- **外部 API 呼び出し**: 長時間 API 応答を待機

### 主な機能

- ✅ **非ブロック**: メイン AI は会話継続可能
- ✅ **ステータス追跡**: リアルタイム進捗レポート
- ✅ **中断可能**: 実行中タスクのキャンセル対応
- ✅ **双方向通信**: タスクはメイン Agent に通知可能

---

## コア API

### 1. 非同期タスクの定義

`mount_async_task` デコレータを使用して非同期タスク関数を登録：

```python
from nekro_agent.services.plugin.task import AsyncTaskHandle, TaskCtl, task
from nekro_agent.api.plugin import NekroPlugin
from typing import AsyncGenerator

plugin = NekroPlugin(
    name="マイ非同期プラグイン",
    module_name="my_async_plugin",
    description="非同期タスク例プラグイン",
    version="1.0.0",
    author="开发者",
    url="https://github.com/xxx",
)

@plugin.mount_async_task("my_task")
async def my_async_task(
    handle: AsyncTaskHandle,
    prompt: str,
    task_id: str,
) -> AsyncGenerator[TaskCtl, None]:
    """非同期タスク例"""
    # 進捗レポート
    yield TaskCtl.report_progress("🔍 要件を分析中...", 10)

    # キャンセル確認
    if handle.is_cancelled:
        yield TaskCtl.cancel("タスクキャンセル済み")
        return

    # タスクステップ実行
    yield TaskCtl.report_progress("⚙️ 処理中...", 50)

    # タスク完了
    yield TaskCtl.success("処理完了", data={"result": "success"})
```

### 2. タスク制御シグナル (TaskCtl)

タスクは `yield TaskCtl.xxx()` でステータスを報告：

| メソッド | 説明 | 終端 |
|----------|------|------|
| `TaskCtl.report_progress(msg, percent)` | 進捗レポート | ❌ |
| `TaskCtl.success(msg, data)` | 成功 | ✅ |
| `TaskCtl.fail(msg, error)` | 失敗 | ✅ |
| `TaskCtl.cancel(msg)` | キャンセル | ✅ |

### 3. タスクハンドル (AsyncTaskHandle)

タスク関数は `AsyncTaskHandle` パラメータを受け取り：

| メソッド | 説明 |
|----------|------|
| `handle.wait(key, timeout)` | 外部シグナルを待機 |
| `handle.notify(key, data)` | 待機ポイントに再開を通知 |
| `handle.notify_agent(message)` | メイン Agent に通知 |
| `handle.is_cancelled` | キャンセル確認 |

### 4. グローバルタスク API (task)

`task` グローバルオブジェクトでタスクを制御：

| メソッド | 説明 |
|----------|------|
| `await task.start(type, id, chat_key, plugin, ...)` | タスク開始 |
| `task.is_running(type, id)` | 実行中か確認 |
| `await task.cancel(type, id)` | タスクキャンセル |
| `await task.stop_all()` | 全タスク停止 |
| `task.get_handle(type, id)` | タスクハンドル取得 |

---

## 完了例：WebApp 開発タスク

### 非同期タスクの定義

```python
@plugin.mount_async_task("webapp_dev")
async def webapp_development_task(
    handle: AsyncTaskHandle,
    requirement: str,
    task_id: str,
) -> AsyncGenerator[TaskCtl, None]:
    """WebApp 開発非同期タスク"""
    yield TaskCtl.report_progress("🚀 開発開始...", 0)

    # 開発実行
    success, result = await run_developer_loop(requirement)

    if success:
        yield TaskCtl.report_progress("📦 コンパイル中...", 70)
        yield TaskCtl.success("デプロイ成功", data={"url": url})
    else:
        yield TaskCtl.fail(f"開発失敗: {result}")
```

### タスク開始

```python
from nekro_agent.api.schemas import AgentCtx

@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "create_webapp_task")
async def create_webapp_task(
    _ctx: AgentCtx,
    requirement: str,
) -> str:
    """WebApp 開発タスクを作成"""
    task_id = generate_task_id()

    # 非同期タスク開始（非ブロッキング）
    await task.start(
        task_type="webapp_dev",
        task_id=task_id,
        chat_key=_ctx.chat_key,
        plugin=plugin,
        requirement=requirement,
        task_id=task_id,
    )

    return f"タスク開始: {task_id}"
```

### メイン Agent との対話

```python
# タスク完了後にメイン Agent に通知
await handle.notify_agent(
    f"✅ WebApp デプロイ成功!\n🔗 {url}"
)

# リアルタイムフィードバック（現在操作を中断）
state_obj = runtime_state.get_state(chat_key, task_id)
if state_obj and state_obj.inject_feedback(new_requirement):
    return "⚡ フィードバック注入済み"
```

---

## ベストプラクティス

### 1. タスク設計

```python
# ✅ 推奨：明確なタスクフェーズ
yield TaskCtl.report_progress("📥 リソースダウンロード中...", 20)
yield TaskCtl.report_progress("🔄 処理中...", 60)
yield TaskCtl.report_progress("💾 保存中...", 90)

# ❌ 非推奨：曖昧な進捗
yield TaskCtl.report_progress("処理中...", 50)
yield TaskCtl.report_progress("もう少し...", 80)
```

### 2. エラーハンドリング

```python
try:
    result = await external_api()
    yield TaskCtl.success("完了", data=result)
except TimeoutError:
    yield TaskCtl.fail("API タイムアウト")
except Exception as e:
    yield TaskCtl.fail(f"エラー: {e}")
```

### 3. リソースクリーンアップ

```python
@plugin.on_disabled()
async def cleanup():
    count = await task.stop_all()
    if count > 0:
        logger.info(f"{count} タスク停止済み")
```

### 4. 並行制御

```python
MAX_CONCURRENT_TASKS = 3

@plugin.mount_sandbox_method(SandboxMethodType.TOOL, "start_task")
async def start_task(_ctx: AgentCtx, name: str) -> str:
    active = len([t for t in task.get_running_tasks() if "my_plugin" in t])
    if active >= MAX_CONCURRENT_TASKS:
        raise ValueError(f"最大並行タスク数に達しました ({MAX_CONCURRENT_TASKS})")

    await task.start("my_task", task_id, _ctx.chat_key, plugin, name)
    return f"タスク開始: {task_id}"
```

---

## よくある質問

### Q: 非同期タスクと通常のサンドボックスメソッドの違いは？

| 比較項目 | サンドボックスメソッド | 非同期タスク |
|----------|------------------------|--------------|
| 実行タイミング | 呼び出し時に即時 | 呼び出し後にバックグラウンド |
| メイン会話のブロック | ブロック | 非ブロック |
| ステータス追跡 | なし | 完整進捗 |
| 長時間実行 | 不向き | 向き |
| キャンセル可能 | 不可 | 可能 |

### Q: タスクにユーザー確認を待たせるには？

```python
@plugin.mount_async_task("approval_task")
async def task_with_approval(handle: AsyncTaskHandle, prompt: str):
    yield TaskCtl.report_progress("⏳ 承認待機中...", 50)

    # 外部の notify() 呼び出しを待機
    approved = await handle.wait("approval", timeout=3600)

    if approved:
        yield TaskCtl.success("承認済み")
    else:
        yield TaskCtl.fail("承認タイムアウトまたは拒否")
```

### Q: タスク完了後にユーザーに通知するには？

```python
await handle.notify_agent(
    f"✅ タスク完了!\n結果: {result}"
)
```

---

## バージョン情報

- **機能バージョン**: nekro-agent v2.2.0+
- **ドキュメントバージョン**: 1.0.0
- **最終更新**: 2026-01-30
